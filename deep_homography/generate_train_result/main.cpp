/**
 * This program generate train results by the paper--
 * "Deep Image Homography Estimation(https://arxiv.org/pdf/1606.03798.pdf)"
 */

#include <QCommandLineParser>
#include <QDebug>
#include <QDir>
#include <QDirIterator>
#include <QFileInfo>

#include <opencv2/calib3d.hpp>
#include <opencv2/core.hpp>
#include <opencv2/dnn.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

#include <fstream>
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

/**
 * This struct store the info of the images to text
 * @param bp_img_ This is the image after resize(without pretube)
 * @param bpp_img_ This is the image after resize(after pretube)
 * @param p_img_ This is the image patch for training(without pertube)
 * @param pp_img_ This is the image patch for training(after pertube)
 * @param delta_ This is the delta mentioned by the paper
 * @param pertube_cordi_ This is the pertube coordinate mentioned by the paper
 */
struct file_info
{
    std::string bp_img_;
    std::string bpp_img_;
    std::string p_img_;
    std::string pp_img_;
    cv::Mat origin_cordi_;
    cv::Mat delta_;

    friend ostream& operator<<(ostream &os, file_info const &info)
    {
        os<<"patch image: "<<info.p_img_<<", "<<info.pp_img_<<endl;
        os<<"resize image: "<<info.bp_img_<<", "<<info.bpp_img_<<endl;
        os<<"delta coordinate"<<endl;
        os<<info.delta_;
        os<<"origin coordinate"<<endl;
        os<<info.origin_cordi_<<endl;
        return os;
    }
};

/**
 * Collection of data parsed from command line
 * @param folder_ folder of the images and info.txt generated by data_generator(https://github.com/stereomatchingkiss/blogCodes2/tree/master/deep_homography/data_generator)
 * @param model_ Location of the model(ex : "../cnn/torch/squeeze_net_500032/squeeze_homo")
 * @param save_at_ Where to save generated results
 */
struct parsed_data
{
    std::string folder_;
    std::string model_;
    std::string save_at_;
};

void create_parser(QCommandLineParser &parser);
void generate_train_results(std::vector<file_info> const &info,
                            QCommandLineParser &parser);
std::vector<file_info> parse_info_txt(QCommandLineParser const &parser);

int main(int argc, char *argv[])try
{
    QCoreApplication a(argc, argv);

    QCommandLineParser parser;
    create_parser(parser);
    parser.process(a);

    if(!parser.isSet("folder")){
        qDebug()<<"folder is empty";
        return -1;
    }

    if(!parser.isSet("save_at")){
        qDebug()<<"save_at is empty";
        return -1;
    }

    if(!parser.isSet("model")){
        qDebug()<<"model is empty";
        return -1;
    }

    std::vector<file_info> const &info = parse_info_txt(parser);
    if(info.empty()){
        qDebug()<<"info.txt do not have any data";
        return -1;
    }

    QDir dir;
    dir.mkdir(parser.value("save_at"));

    generate_train_results(info, parser);

    return 0;
}catch(std::exception const &ex){
    qDebug()<<ex.what()<<endl;
}

cv::Mat read_image(std::string const &img_name, int flags = IMREAD_GRAYSCALE)
{
    Mat img = imread(img_name, flags);
    if(img.empty()){
        throw std::runtime_error("Cannot open image:" + img_name);
    }

    return img;
}

cv::Mat convert_to_blob(cv::Mat &inout_1, cv::Mat &inout_2)
{
    inout_1.convertTo(inout_1, CV_32F);
    inout_2.convertTo(inout_2, CV_32F);
    int sz[] = {1, 2, 128, 128};
    Mat blob(4, sz, CV_32F);
    inout_1.copyTo(Mat(128, 128, CV_32F, blob.ptr(0, 0)));
    inout_2.copyTo(Mat(128, 128, CV_32F, blob.ptr(0, 1)));
    blob /= 255.0;

    return blob;
}

template<typename T>
vector<T> convert_to_pt(cv::Mat const &input)
{
    vector<T> draw_points;
    for(size_t i = 0; i != 8; ){
        T const pt(input.at<float>(0, i), input.at<float>(0, i + 1));
        i +=2;
        draw_points.emplace_back(pt);
    }
    std::swap(draw_points[3], draw_points[2]);

    return draw_points;
}

void generate_train_results(std::vector<file_info> const &info,
                            QCommandLineParser &parser)
{
    string const model(parser.value("model").toStdString());
    dnn::Net net = dnn::readNetFromTorch(model);
    if(net.empty()){
        qDebug()<<"Can't load network by using the mode file:"<<model.c_str();
        throw std::runtime_error("net is empty");
    }

    for(file_info const &inf : info){
        std::string const folder = parser.value("folder").toStdString();
        Mat pimg = read_image(folder + "/" + inf.p_img_);
        Mat ppimg = read_image(folder + "/" + inf.pp_img_);
        Mat const blob = convert_to_blob(pimg, ppimg);
        net.setInput(blob);

        Mat const predict_delta = net.forward();
        Mat const predict_pertube_cordi = predict_delta + inf.origin_cordi_;
        Mat const pertube_cordi = inf.delta_ + inf.origin_cordi_;

        Mat resize_img = read_image(folder + "/" + inf.bp_img_, cv::IMREAD_COLOR);
        Mat const hmat = getPerspectiveTransform(convert_to_pt<Point2f>(inf.origin_cordi_),
                                                 convert_to_pt<Point2f>(pertube_cordi));
        Mat resize_img_pertube;
        warpPerspective(resize_img, resize_img_pertube, hmat, resize_img.size());

        polylines(resize_img, convert_to_pt<Point>(inf.origin_cordi_), true, {255, 0, 0}, 2);
        polylines(resize_img_pertube, convert_to_pt<Point>(pertube_cordi), true, {255, 0, 0}, 2);
        polylines(resize_img_pertube, convert_to_pt<Point>(predict_pertube_cordi), true, {0, 0, 255}, 2);
        std::string const save_folder(parser.value("save_at").toStdString());
        imwrite(save_folder + "/origin_" + inf.bp_img_, resize_img);
        imwrite(save_folder + "/warp_" + inf.bp_img_, resize_img_pertube);
    }
}

void create_parser(QCommandLineParser &parser)
{
    parser.setApplicationDescription("Generate training results by the model");
    parser.addHelpOption();

    parser.addOption({{"f", "folder"},
                      "Folder of the images",
                      "folder"});
    parser.addOption({{"m", "model"},
                      "Location of model(ex : ../cnn/torch/squeeze_net_500032/squeeze_homo)",
                      "model"});
    parser.addOption({{"s", "save_at"},
                      "Where to save generated results",
                      "save_at"});
}

std::vector<file_info> parse_info_txt(QCommandLineParser const &parser)
{
    std::ifstream in(parser.value("folder").toStdString() + "/info.txt");
    if(!in.is_open()){
        throw runtime_error("cannot open info.txt");
    }

    std::vector<file_info> results;
    file_info info;
    std::string line;
    while(std::getline(in, line)){
        std::stringstream stream(line);
        stream>>info.p_img_>>info.pp_img_;
        auto copy_points = [&info, &stream](cv::Mat &points)
        {
            points.create(1, 8, CV_32F);
            for(size_t i = 0; i != 8; ++i){
                float val = 0;
                stream>>val;
                points.at<float>(0, i) = val;
            }
        };
        copy_points(info.delta_);
        copy_points(info.origin_cordi_);
        stream>>info.bp_img_>>info.bpp_img_;
        //cout<<info<<endl;
        results.emplace_back(std::move(info));
    }

    return results;
}
